NodePoolManager ToDo list

* When NPM starts, NodeRegistry should be filled with nodes retrieved from the cloud provider. (I think it is done)

* Make FixedCloudProvider deal with several VMs

* Is indeed useful a REST operation POST /nodes/{id}/configs
So we can deploy a given configuration in a specific node

* The POST /configs should support receiving a list of configs,
and not only one config 

* Disable third party library log in our log generated by log4j

* ALWAYS_CREATE corresponds to VerySimpleSelector, but VerySimpleSelector does not always create a new node

* Before managing the node, we could trigger the ntpdate command on the node (through ssh)

* Concurrent requests can trigger concurrent bootstraps on the same node!
It's not desirable. However, often recipes are applied when node is already bootstrapped,
since 'create node' also bootstraps the node.
This is the reason why ParallelDeployTest "works only if the node is already bootstrapped"
Obs: in a situation of concurrent boostrapps, the node got no bootstrapped at al
and NPM did not detect it!

* Giving up from unavailable VM
Sometimes a requested VM does not get ready to use.
The consequence is that the SSH keeps failing on.
When SSH failures take so long, we should give up the VM and request another VM.

* BUG:
Cannot run program "knife" (in directory "/home/leonardo/workspaces/choreos/chef-repo")
Bootstrap completed at Node ... // this second message should be a failures message

* Verify somehow if node upgrade was indeed successful (NodeUpgrader class)

=============================

Service Deployer ToDo list

* easyesb output appends the "esb@localhost:/>" prompt to the log over and over again.
We have to avoid this.

* Describe Chef-Server setup (example: Java and Tomcat recipes must be available)
Better idea: say to the user to install all the recipes of our cookbook folder in his server.

* Improve javadoc of REST operations (ex: detail return codes)

* The POST /services should support receiving a list of services,
and not just one service

* jar file names get very ugly
Download the jar name with its original name

* DELETE /services/{id} should really remove service from deployment

* Separete JAR and WAR recipes in different cookbooks

* Current ServiceType is not actually the type of the service,
but the type of the deployable artifact.
Maybe we should rename ServiceType and use ServiceType to know if
service is SOAP, REST, JMS etc.
This new information will be useful to make ContextSender an extensible point.

* Rename ServiceDependence to ServiceDependency

* Make COMMNAD_LINE support tar.gz packages.

* ServiceSpec should have an attribute 'version'
It will be important later to upgrade choreographies.

* Since ServiceType and ArtifactType are intended to be extended, 
they cannot be simple enums.
Solution (by C Moraes): to use the type safe enum pattern.
Create a class ServiceType, that has a private constructor 
and initializes a set of instances based on a config file.
Default values can have constants pointing to them (e.g. SOAP = new ServiceType('SOAP')),
but to access non-defualt values it is necessary something like
ServiceType.getInstanceByName("JMS").

============ DONE ============

* Create a Java project Utils to avoid code replication
Its the Commons project, but NPM is not using it yet

* POST /nodes/configs is returning the node ip on location header
It should return the node id in the location header
and it would be better return the node representation on the body response

* To change initial message from "Node Pool Manager is started..."
to "Node Pool Manager has started in http://localhost:9100/nodepoolmanager/"
This applies to ServiceDeployer and StorageFactory as well

* Pick up already existing nodes in order to reduce middleware testing time

* Change package name

* Bring NPM client to NPM project

* The singleton instance management of NodeSelector implementation
should be performed by the implementing classes themselves,
and not by the Factory class.
So, the FactoryClass can just call NodeSelectorImpl.getInstance()
-> Aborted. Not so good, since NodeSelector must receive a CloudProvider in its constructor

* NPM project must use the Commons project

* Controller, as NPMClient, should implement the interface NodePoolManager

* Controller should be singleton
Should it? I did not do this.

* Maybe it would be better a single server class to expose the REST operations,
and not one class to NPM and another class to Service Deployer

* We were having problems with concurrent calls to EC2 and knife APIs.
The problem was that to add an item to the run-list, Knife downloads the whole node description,
chenge the run-list, and uploads the new node description. This approach does not support concurrency.
We have handled this by synchronizing the add run-list operation.
But if this invocation is triggered from different JVMs, we still have problems!

* Concurrent invocations to RecipeBuilderImpl.copyTemplate (to the same target) causes IOException.
But the synchronized there should avoid this!
If exception is caught, we verify if target folder already exists.
If it exists, we assume is everything OK.

* Bootstrap verification: think in a better way than checking getting-started.txt
We do not install the getting-started recipe anymore.
We just check if the node is listed by the "knife node list" command.

* By default, don't generate a recipe if it was already generated

* Change enumerations in ServiceType
JAR -> COMMAND_LINE; WAR -> TOMCAT

* Should service.file attribute be removed?
Now we have just the serviceSpec.getFileName() method.

* After applying a configuration, use "knife node show NODE" to verify if the recipe was installed with success
If not, return an error

* Avoid null returns when exception would be more appropriate.
Important places to change this: NodePoolManager, ServideDeployer, and EnactmentEngine interfaces.

* Improve javadoc of REST operations (ex: detail return codes) // NPM

* It seems there is some overlapping between INSTALL and README files. Handle this.

* In CD deploy recipe: execute client just after server is properly running

* Move properties file to conf folder
After some research, it does not sound a good idea anymore.

* ConfigurationManager is a too big class, let's break it!
A first step is creating a class responsible by invoking the chef-client in a node.
The refactoring will be OK if all the new classes could be easily unit-tested.

* Create external_links file
So, if we lost valinhos, for example, it will be easier to change the links


