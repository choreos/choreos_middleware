NodePoolManager ToDo list

* Concurrent requests can trigger concurrent bootstraps on the same node!
It's not desirable. However, often recipes are applied when node is alredy bootstrapped,
since 'create node' also bootstraps the node.

* Improve javadoc of REST operations (ex: detail return codes)

* It seems there is some overlaping between INSTALL and README files. Handle this.

* After applying a configuration, use "knife node show NODE" to verify if the recipe was installed with success
If not, return an error

* Make FixedCloudProvider deal with several VMs

* Is indeed useful a REST operation POST /nodes/{id}/configs
So we can deploy a given configuration in a specific node

* The POST /configs should support receiving a list of configs,
and not only one config 

* Disable third party library log in our log generated by log4j

* ALWAYS_CREATE corresponds to VerySimpleSelector, but VerySimpleSelector does not always create a new node

* Bootstrap verification: think in a better way than checking getting-started.txt

* Before managing the node, we could trigger the ntpdate command on the node (through ssh)

* Think better about exceptions in NodePoolManager, ServiceDeployer, and EnactmentEngine interface

* When NPM starts, NodeRegistry should be filled with nodes retrieved from the cloud provider.


=============================

Service Deployer ToDo list

* DeployedServicesRegistry: improvement needed?
Is it possible to interact with chef to store data?

* The POST /services should support receiving a list of services,
and not just one service

* Improve javadoc of REST operations (ex: detail return codes)

* It does not seem nice that the service deployer client has to call npm.upgradeNodes operation
A possible solution would be the service deployer server running npm.upgradeNodes periodically

* Describe Chef-Server setup (example: Java and Tomcat recipes must be available)

* Change enumarations in ServiceType
JAR -> COMMAND_LINE; WAR -> TOMCAT

* Concurrent invocations to RecipeBuilderImpl.copyTemplate (to the same target) causes IOException.
But the synchronized there should avoid this!

* Don't upload a cookbook if it is already on the server
Check by cookbook name and version

============ DONE ============

* Create a Java project Utils to avoid code replication
Its the Commons project, but NPM is not using it yet

* POST /nodes/configs is returning the node ip on location header
It should return the node id in the location header
and it would be better return the node representation on the body response

* To change initial message from "Node Pool Manager is started..."
to "Node Pool Manager has started in http://localhost:9100/nodepoolmanager/"
This applies to ServiceDeployer and StorageFactory as well

* Pick up already existing nodes in order to reduce middleware testing time

* Change package name

* Bring NPM client to NPM project

* The singleton instance management of NodeSelector implementation
should be performed by the implementing classes themselves,
and not by the Factory class.
So, the FactoryClass can just call NodeSelectorImpl.getInstance()
-> Aborted. Not so good, since NodeSelector must receive a CloudProvider in its constructor

* NPM project must use the Commons project

* Controller, as NPMClient, should implement the interface NodePoolManager

* Controller should be singleton
Should it? I didnot do this.

* Maybe it would be better a single server class to expose the REST operations,
and not one class to NPM and another class to Service Deployer

* We were having problems with concurrent calls to EC2 and knife APIs.
The problem was that to add an item to the run-list, Knife downloads the whole node description,
chenge the run-list, and uploads the new node description. This approach does not support concurrency.
We have handled this by synchronizing the add run-list operation.
But if this invocation is trigegred from different JVMs, we still have problems!




